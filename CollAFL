CollAFL-Path Sensitive Fuzzing

现有模糊器存在的问题：
现有的一些模糊测试器大多为基于覆盖引导的模糊测试，例如：Libfuzzer和honggfuzz利用clang中的SanitizerCoverage组件来跟踪块覆盖信息，VUzzer利用PIN工具来跟踪块覆盖信息，AFL利用动态/静态分析来跟踪边缘覆盖信息。
以上这些模糊器都是使用较为简单的覆盖信息，这种覆盖的不准确和不完整给测试带来了严重的局限性。

其主要存在两个弊端：
（1）路径冲突，从而影响fuzzing挖掘出导致新崩溃的潜在路径。
由于AFL中对边计算哈希值是采用固定的公式进行计算的，因此很容易产生路径冲突的情况。CollAFL则通过三种针对不同情况的算法实现对边的唯一赋值，减少哈希冲突，提高覆盖信息的精确性。
（2）影响fuzzing的最优决策（种子优先级排序等等）。
CollAFL则基于三个基本情况：
·内存操作次数越多，内存发生崩溃的可能就越大。拥有更多内存访问操作的种子将优先于模糊，该策略使用内存访问操作的数量作为测试用例的权重。
·拥有更多未触及的邻近分支的种子将优先于模糊，该策略使用未接触的临近分支数作为测试用例t的权重。未触及的邻居分支的数量作为该种子的权重。
·拥有更多未受影响的邻近后代的种子将优先考虑模糊，该策略使用未接触的邻近后代的数量作为测试用例的权重。

综上，memory-access guided考虑的是内存访问，CollAFL统计这个种子所走的路径，基本块访问的数量，那些访问数量多的，优先级就相应高一点。
untouched-branch guided考虑的是，每个种子会走一条路径，一条路径实际有不同分支的，有些分支是被其他种子测过，有的分支没有。然后CollAFL统计这个种子多样分支被测过，有多少分支没有被测过，于是就有可能出现两个种子。第一个种子有一个分支没测过，第二个种子有N个分支没测过。CollAFL选择的就是后者，因为在第二个进行变异的时候有非常大的概率，种子存在没有被触发、测试过的分支。
untouched-descendant guided是在untouched-branch guided的基础上改进，untouched-branch guided中的分支记为 1，此处分支后面会跟着一些子路径，所以也要考虑子路径的数目，因此计数不再是 1，而是把后面的分支根据路径数量加进来。


另外，虽然扩大bitmap能够有效减少路径冲突，但在实际中这是不可行的，运算速度下降，性价比低。

代码覆盖率的准确性对于覆盖率引导的模糊器是至关重要的。CollAFL为路径冲突问题提出了一个较好的解决方案，没有单纯地利用扩大bitmap来避免路径冲突，在覆盖精度和性能之间找到一个平衡点。
